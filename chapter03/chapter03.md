## chapter 03
### 03-1 추상 자료형 : Abstract Data Type
- 추상 자료형(ADT)
- 구체적인 기능의 완성과정을 언급하지 않고, 순수하게 기능이 무엇인지를 나열한 것

### 03-2 배열을 이용한 리스트의 구현
- 순차 리스트 : 배열을 기반으로 구현된 리스트
- 연결 리스트 : 메모리의 동적 할당을 기반으로 구현된 리스트
- 리스트 특성
  - 데이터를 나란히 저장
  - 중복된 데이터의 저장 허용
- 리스트의 ADT (교재와는 다르게 자바 기반으로 작성하므로 자바 구현체를 참조하여 구현한다)
  - init
    - java기반으로 작성하므로 생성자로 대체함
  - insert
    - 교재 : int insert(List *plist, Data data); 
    - 위 코드는 C언어 기반이므로 plist 주소값이 필요하다고 생각된다.
    - java 기반이므로 E insert(data) 를 기반으로 작성하겠다.
  - first
    - 현재 위치 정보 = 0
    - 처음 데이터를 반환
  - next
    - 현재 위치 정보 증가
    - 다음 데이터를 반환
  - remove
    - 삭제하고 데이터 반환
    - C언어 삭제 후 데이터를 반환하는 이유 (<strong>리스트는 메모리의 해제까지 책임을 지지 않는다</strong>)
      - free 함수를 통한 메모리의 해제 과정이 필요할 수 있다
      - 동적 할당 받은 데이터를 반환하여 메모리 소멸의 기회를 줄 수 있어야한다.
    - Java에서는 메모리 관리를 자동으로 수행하기 때문에, 객체가 더 이상 참조되지 않을 때 가비지 컬렉터가 자동으로 메모리를 해제합니다.
    - 따라서, ArrayList 클래스의 remove() 메서드에서 객체를 제거하는 것만으로, 해당 객체에 대한 참조가 더 이상 존재하지 않게 되므로, 가비지 컬렉터가 자동으로 메모리를 회수합니다. 
    - 코드에서 remove() 메서드는 배열 내의 요소를 삭제한 후, 배열의 요소를 시프트하여 삭제된 요소의 자리를 채우고 numOfData와 curPosition을 조정합니다. 
    - 이 과정에서 객체 자체를 null로 설정하지 않고 배열 내에서 단순히 요소를 이동시키므로, 해당 객체는 여전히 메모리에 존재하지만, 배열의 참조에서 벗어나게 됩니다.
  
  - count
  
- 배열 기반 리스트의 단점
  - 배열의 길이가 초기에 결정 -> 변경이 어렵다
  - 삭제의 과정에서 데이터의 이동이 매우 빈번히 일어나고, 중간에 삽입하기 어렵다
- 배열 기반 리스트의 장점
  - 데이터의 참조가 쉽다. 인덱스 값을 기준으로 한 번에 참조가 가능하다

---
문제 03-2 리스트의 활용
- 교재 활용
- NameCard
- NameCardMain